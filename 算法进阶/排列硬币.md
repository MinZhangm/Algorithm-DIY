你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。

给定一个数字 n，找出可形成完整阶梯行的总行数。

方法一：
  
  迭代，每次取出不大于剩余硬币数的硬币组成一行，当剩余数目下雨需要取出的硬币数时返回行数。
  
方法二：

  二分查找，总共的行数不会超过硬币总数。二分查找，假设中间数是答案行数。然后计算如果是这么多行，需要多少个硬币，如果小于硬币总数，那么右边二分，如果大于硬币总数那么左边二分。
  需要注意边界条件。左边是1，右边是n，如果恰好等于直接返回，否则遍历结束，返回左边位置。
  
  注意边界怎么选，二分法的中点的选取有两种方法。(l + r) // 2 等价于 l + (r - l)//2
  
  怎么设定更新边界的条件：因为斌不是都能正好保证所有的硬币都组成恰好的阶梯，
  target < n-mid:表示的是，至少再来一行和当前这行同样的数量的硬币，好美超过所有的硬币的总数。如果超了右指针就移到目前的 mid，所以最终返回的是右指针，表示能取到的最后的位置是多少。
  
  
```python
class Solution:
    def arrangeCoins(self, n: int) -> int:
        l, r = 0, n
        while l < r:
            mid = l + (r-l)//2
            tmp = (mid + 1) * mid / 2
            if tmp == n:
                return mid
            elif tmp < n - mid:
                l = mid + 1
            else:
                r = mid
        return r
```
